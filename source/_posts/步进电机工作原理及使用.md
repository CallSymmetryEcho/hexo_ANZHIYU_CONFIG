---
title: 步进电机工作原理及使用,自动泡片机制作
tags: 
- robotic
- ProjChatGPT 
- AI 辅助学习
- Projects
cover: https://lskypro.bin-lian.me/i/2025/01/01/6774a45202abc.png
categories: 
- [转载,Projects,PCB]
--- 

良好的学习资源：
[Stepper Motors and Arduino - The Ultimate Guide (howtomechatronics.com)](https://howtomechatronics.com/tutorials/arduino/stepper-motors-and-arduino-the-ultimate-guide/)
[How Stepper Motors Work](https://howtomechatronics.com/how-it-works/electrical-engineering/stepper-motor/)  
[认识步进驱动器 | 北岛夜话 (founderchip.com)](https://www.founderchip.com/?id=264)
[步进电机基础知识：类型、用途和工作原理|技术文章|MPS (monolithicpower.cn)](https://www.monolithicpower.cn/cn/stepper-motors-basics-types-uses)
模拟工具推荐：
https://www.tinkercad.com/
本博客创建为学习这个网站的笔记，并且转载该博客内容

## 自己的代码和实现的项目

### 步进电机的基本原理
(参照 Dejan博客，收集与下文)
### 步进电机不同driver 的接线
[![A4988 and Arduino Connection - Wiring Diagram](assets/img/a/8/b/a8b9af75b656c511818589df51bd7aad1739ac58190b1e46576ad40fac897b20.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/A4988-and-Arduino-Connection-Wiring-Diagram.png)
A4988driver

![[markdown note/Pasted image 20230217014307.png]]
TB6600


### Auto-immersion-lifter的实现

##### Aduino code:
~~~ c
#include <AccelStepper.h>

  

// Define the stepper motor and the pins that is connected to

AccelStepper stepper1(1, 3, 7); // (Typeof driver: with 2 pins, STEP, DIR)

  

void setup() {

Serial.begin(9600);

stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper

stepper1.setAcceleration(500); // Set acceleration value for the stepper

stepper1.setCurrentPosition(0); // Set the current position to 0 steps

}

  

void loop() {

if (Serial.available() > 0) {

String incomingString = Serial.readStringUntil('\n'); // Read until the "Enter" button is pressed

incomingString.trim(); // Remove leading/trailing whitespaces

if (incomingString == "lift") {

Serial.println("Enter number of steps to move:");

while (!Serial.available()); // Wait until a character is received

int stepsToMove = Serial.parseInt(); // Read an integer from the serial buffer

Serial.print("Moving UP by ");

Serial.print(stepsToMove);

Serial.println(" steps");

stepper1.moveTo(stepsToMove); // Set desired move: stepsToMove steps

stepper1.runToPosition(); // Moves the motor to target position

} else if (incomingString == "back") {

Serial.println("Moving back to original position");

stepper1.moveTo(0);

stepper1.runToPosition();

}

else if (incomingString == "set0"){

stepper1.setCurrentPosition(0);

}

}

}
~~~
这里需要提及的是：读取字符串的判断,第一版写法：
``` c
 if (Serial.available() > 0) {
    String incomingString = Serial.readString();
    if (incomingString == "lift") {
      Serial.println("Moving down 15000 steps");
      stepper1.moveTo(15000); // Set desired move: 15000 steps
      stepper1.runToPosition(); // Moves the motor to target position with acceleration/deceleration and blocks until it is in position
    }
```
可以成功读取，但是无法满足判断条件，怀疑是一起读取了'enter' '\n'于是使用chatgpt 检查并确认,同时向Chatgpt 学习数字的读取使用Serial.parseInt()



Q:Could it be also because I type the "enter" botton and it be count as part of the string?

>A :Yes, that could be the problem. When you type a string followed by the "Enter" button, the "Enter" button is also sent as a character to the serial buffer, which is then read by the `Serial.readString()` function as part of the string.

To solve this problem, you can use the `Serial.readStringUntil()` function instead of `Serial.readString()`. The `Serial.readStringUntil()` function reads the serial buffer until a specific character is encountered and then returns the received string.

Here's the modified code that uses `Serial.readStringUntil()` to read the input string until the "Enter" button is pressed:

``` c
#include <AccelStepper.h>

// Define the stepper motor and the pins that is connected to
AccelStepper stepper1(1, 3, 7); // (Typeof driver: with 2 pins, STEP, DIR)

void setup() {
  Serial.begin(9600);
  stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper
  stepper1.setAcceleration(500); // Set acceleration value for the stepper
  stepper1.setCurrentPosition(0); // Set the current position to 0 steps
}

void loop() {
  if (Serial.available() > 0) {
    String incomingString = Serial.readStringUntil('\n'); // Read until the "Enter" button is pressed
    incomingString.trim(); // Remove leading/trailing whitespaces
    if (incomingString == "lift") {
      Serial.println("Moving down");
      stepper1.moveTo(15000); // Set desired move: 15000 steps
      stepper1.runToPosition(); // Moves the motor to target position
    } else if (incomingString == "back") {
      Serial.println("Moving back to original position");
      stepper1.moveTo(0);
      stepper1.runToPosition();
    }
  }
}

```

The modified code reads the input string until the "Enter" button (`\n` character) is pressed and then removes the leading/trailing whitespaces using the `String.trim()` function.



>Sure! To add a function that allows you to enter the moving steps from Python, you can use the `Seri
>al.parseInt()` function to read an integer value from the serial buffer.


```c
scss#include <AccelStepper.h>

// Define the stepper motor and the pins that is connected to
AccelStepper stepper1(1, 3, 7); // (Typeof driver: with 2 pins, STEP, DIR)

void setup() {
  Serial.begin(9600);
  stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper
  stepper1.setAcceleration(500); // Set acceleration value for the stepper
  stepper1.setCurrentPosition(0); // Set the current position to 0 steps
}

void loop() {
  if (Serial.available() > 0) {
    String incomingString = Serial.readStringUntil('\n'); // Read until the "Enter" button is pressed
    incomingString.trim(); // Remove leading/trailing whitespaces
    if (incomingString == "lift") {
      Serial.println("Enter number of steps to move:");
      while (!Serial.available()); // Wait until a character is received
      int stepsToMove = Serial.parseInt(); // Read an integer from the serial buffer
      Serial.print("Moving down by ");
      Serial.print(stepsToMove);
      Serial.println(" steps");///same as.print
      stepper1.moveTo(stepsToMove); // Set desired move: stepsToMove steps
      stepper1.runToPosition(); // Moves the motor to target position
    } else if (incomingString == "back") {
      Serial.println("Moving back to original position");
      stepper1.moveTo(0);
      stepper1.runToPosition();
    }
  }
}

```

The modified code first waits for the "lift" command to be received, and then sends a prompt to enter the number of steps to move. It then waits for an integer value to be received from the serial buffer using the `Serial.parseInt()` function.

Once the number of steps is received, the motor is moved by the specified number of steps, and the action is confirmed with a message sent back to Python through the serial port.

##### PCB板控制端，给出串口，由python接管调用功能
~~~ python
ser = serial.Serial('/dev/cu.usbserial-14210', 9600)  
# wait for the Arduino to reset  
while(True):  
        inp = input('Choose the mode: ')  
        if inp == 'q':  
            break  
        elif inp == 'SI_tunning':  
            while True:  
                command = input('Input command: ')  
                if command =='quit':  
                    break # exit the SI mode loop and go back to the top-level loop  
                ser.write(str.encode(command))  
                line = ser.readline().decode().rstrip()  
                print(line)  
  
        elif inp =='Si_etching':  
            si_length = float(input('Si_length unit (um) '))  
            etching_speed =float(input('etching speed(um/min) '))  
            si_etching_control(si_length,etching_speed,12000)  
  
# close the serial connection  
ser.close()
~~~
## What is a Stepper Motor and How It Works?

I will start with briefly explaining what is stepper motor and how it works, as it will help us better understand everything else in this tutorial. 

[![Inside of NEMA 17 Stepper motor - How It Works](assets/img/0/a/c/0acb62bcb3d7ab5ee6d3a363ba0a9750be5d3ad625d26cf9ef357972213ac968.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Inside-of-NEMA-17-Stepper-motor-How-It-Works.jpg)

A stepper motor is a unique type of brushless DC motor which position can be precisely controlled even without any feedback.

The working principle of a stepper motor is based on magnetic fields. It has two main components, a stator(定子) and a rotor（转子）. The rotor is usually a permanent magnet and it’s surrounded by some coils on the stator.

[![Stepper Motor main components - stator and a rotor](assets/img/b/d/2/bd2bb823bd18d25e746caa481f2d42b57bb6ba5d845be8024019064a22e47674.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Stepper-Motor-main-components-stator-and-a-rotor.png)

When we energize or let current flow through the coils, particular magnetic fields are generated in the stator that either attract or repel the rotor. By activating the coils, step by step, one after another in a particular order, we can achieve continues motion of rotor, but also, we can make it stop at any position.

[![Stepper-Motor-Working-Principle](assets/img/d/9/3/d93ec925c16dc1e78d5ae6b65de71bdc2b6c495e750148c81d77a53bed58e568.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Stepper-Motor-Working-Principle.png)

So, that’s why these motors are called stepper motors, they move in discrete steps. 

By increasing the number of magnetic poles on the rotor, we can increase the number of possible stopping positions, thus increase the resolution or the precision of the motor. Please note that this is just a basic explanation and you can find more details in my [How Stepper Motors Work](https://howtomechatronics.com/how-it-works/electrical-engineering/stepper-motor/) tutorial. 

A typical stepper motor, a NEMA17 for example, has 50 stopping points or steps on the rotor. On the other hand, the stator can have several coils organized in two phases which provide four different magnetic field orientations or positions.

[![Stepper motor - 50 Steps, 2 phases and 4 different magnetic field orientations ](assets/img/5/c/e/5ced8b0a2dc533910da024db5d68d88f636641e4338d13cfbefe0d960b28b7f8.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Stepper-motor-50-Steps-2-phases-and-4-different-magnetic-field-orientations-.png)

So, the 50 steps of the rotor multiplied by the 4 different magnetic field orientations, make total of 200 steps for completing a full rotation. Or if we divide 360 degrees by 200 steps, that’s a resolution of 1.8 degrees per step.

I mentioned that the stator coils are organized in two phases, and we can also notice that if we take a look at number of wires of a stepper motor. It has 4 four wires, two for each phase. The four different magnetic field orientations are possible as we can let current flow through the phases in both directions.

[![Current flow through the phases - stepper motor working principle](assets/img/0/9/a/09a39a9c62e5fecd59e42b9eb484dcdbea3f2cc775b67b8267cbbed5bcf88c03.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Current-flow-through-the-phases-stepper-motor-working-principle.jpg)

There also stepper motors with 5, 6 or even 8 wires, but they still work on two phases or we control them with just four terminals.

[![6-wire and 8-wire stepper motor connection in bi-polar configuration](assets/img/8/5/7/8570c292188725ff738674152f9dc368992813b326647e949f7b8d44df8f5c98.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/6-wire-and-8-wire-stepper-motor-connection-in-bi-polar-configuration.png)

The thing with them is that they can provide different performance characteristics, like more torque or more speed, depending on how we connect these wires on the four control terminals.

Nevertheless, with this brief explanation, now we understand that for driving a stepper motor, we cannot just connect power to it as nothing will happen. Instead, we have to energize the two motor phases in both directions, and activate or send pulses to them in particular order, in a timely sequence. So, that’s why we need drivers for controlling stepper motors. 

There are many types and sizes of drivers, corresponding to the many types and sizes of stepper motors. However, the basic working principle of all of them is that they have two H-Bridges that allow energizing the motor phases in both directions.

[![H-bridge inside a stepper motor driver - how it works](assets/img/d/3/7/d3783d35322b0665a7167189dd2508167591c19d9ea09eeff7e44244c6d5c82c.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/H-bridge-inside-a-stepper-motor-driver-how-it-works.png)

Of course, they have many other functions like micro stepping, current limiting, and so on that enable us to easily control the stepper motors, which is the whole purpose of them.

## How To Control NEMA17 Stepper Motor with Arduino and A4988 Stepper Driver

All right, now we can take a look at the first example for this tutorial, how to control a NEMA 17 stepper motor with an A4988 stepper driver. 

All right, now we can take a look at the first example for this tutorial, how to control a NEMA 17 stepper motor with an A4988 stepper drive.

![Stepper motor control with Arduino and A4988 stepper driver - example](assets/img/4/a/7/4a7a3c8a5dfee3b288cc57c05d80cdfb344448e091f2336a81236c9426cac0ff.webp)

The NEMA17 is the most popular stepper motor among makers, as it offers great performances and it’s affordable at the same time. It can be also found in almost any desktop 3D printer and laser engraver. 

Generally, the NEMA17 stepper motor has 200 steps, or 1.8 degrees per step resolution, but there are also models with 400 steps and 0.9 degrees per step resolution. We should note here that the designation NEMA17 actually describes just the size of the motor in terms of the front faceplate size.

![NEMA designation meaning for stepper motors - NEMA17](assets/img/8/3/3/8333d100ccf79d6aa5fca83ac7195c4529f5bff7e1b220b737cc931a450b4470.webp)

The number stands for the size of faceplate in inches when divided by 10, or in this case that would be 17 divided by 10 equals 1.7 inches faceplate, or 2.3 inches faceplate in case of NEMA23.

So, the faceplate size is fixed, but the length of the NEMA17 steppers can vary from 20mm to 60mm, and with that the power requirement of the motor also varies. The power requirement is usually defined by how much current the motor is allowed to draw, and the range for these NEMA17 steppers motors is from 0.3A up to 2.5A.

![NEMA17 stepper motor length range from 20mm to 60mm](assets/img/4/3/1/431af86ce9a7292da217adb73f6ea291b6788579277b5dbda829b0e9f790a858.webp)

Now, according to the current rating of the stepper motor, we need to choose a suitable driver which can handle that amount of current. The most popular driver controlling for NEMA17 stepper motors is the A4988 stepper motor driver.

![A4988 Stepper Driver](assets/img/3/1/a/31a4d51c19629937e61ad6495c45b9d8e812758ff217e39d0a1165ec57909708.webp)

The A4988 has a maximum current rating of 2A per coil, but that’s actually a peak rating. It is recommended to keep the current to around 1A, but of course, it is also possible to go up to 2A of good cooling is provided to the IC. 

A great feature the A4988 stepper driver has, actually all other drives have, is the current limiting. With this we can easily set how much current the motor will draw no matter the motor rating. For example, we can connect even a 2.5A rated stepper motor, but we will limit the current of the driver to 1.5A. So, although the motor won’t work at its maximum capacity, we would still be able to use it.

On the other hand, if the motor is rated lower than the set current limit on the driver, the motor would overheat. Of course, it’s always recommended to try to match the current rating of the motor with the current rating of the driver.

### A4988 and Arduino Connection

All right, so now let’s see how to connect the A4988 driver with the stepper motor and the Arduino controller.

[![A4988 and Arduino Connection - Wiring Diagram](assets/img/a/8/b/a8b9af75b656c511818589df51bd7aad1739ac58190b1e46576ad40fac897b20.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/A4988-and-Arduino-Connection-Wiring-Diagram.png)

At top right corner of the driver we have the VMOT and GND pins and here we connect the power supply for the motor which can range 8 to 36V. Here it is also recommended to use a decoupling capacitor across these two pins in order to protect the board from voltage spikes. We should use large electrolytic capacitor with at least 47uF capacity. 

Next, are the four pins where we connect the stepper motor. One phase of the motor goes on 1A and 1B pins, and the other phase on 2A and 2B pins. 

Sometimes, it can be a bit difficult to recognize which two wires of the motor make a phase, but are several ways to identify them. The simplest way is to rotate the shaft of the stepper motor by hand, and then connect two wires to each other. If you connect two wires that make a phase, the rotation of the shaft would be a bit more difficult.

![How to find a phase in a stepper motor - Easy method](assets/img/c/a/a/caa848bbf67be9ff08b10c9ca7ad5ef82b8c05d2997ab608107231b242ecf2aa.webp)

Another way is to use a multimeter and check for continuity between the two wires. If you connect two wires that make a phase, you will have a short circuit and the multimeter will start beeping.

[![](assets/img/6/4/9/649d4d4db65cb6cce3e24ae53ae597d8d2004568ad52df346ac458cb5288294b.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/How-to-find-the-phase-of-a-stepper-motor-which-wires-make-a-phase.jpg)

Once we find a phase, we can connect it to any position of the two positions on the driver, the order doesn’t matter. 

Next, we have the IC or the logic power supply pins, VDD and GND, which can be from 3V to 5V. On the other side we have the Step and the Direction pins, which can be connected to any pin of the Arduino board. With the Direction pin we select the rotation direction of the motor, and with the Step pin we control to steps of the motor. With each pulse we send to the Step pin, the motor will advance one step in the selected direction. 

Right above these pins, we have the Sleep and the Reset pins which are used for, as their names suggest, putting the driver to sleep mode or resetting it. We should note that both of these pins are active low. The Sleep pin by default is HIGH state, but the RST pin is floating. That means in order to have the driver enabled, the easiest way is to just connect these two pins to each other, assuming we won’t use these pins functions. 

The Enable pin is also active low, so unless we pull it HIGH, the driver will be enabled. 

The next three pins, MS1, MS2 and MS3, are for selecting the step resolution of the motor. We already said that the step resolution depends on the construction of the motor which is usually 200 steps per revolution for a NEMA 17 stepper motor. However, all stepper drivers have this feature called microstepping which allows driving the motor at higher resolutions. This is achieved by energizing the coils at an intermediate current level, which produce intermediate step locations.

[![](assets/img/5/6/0/560a19b475a999ff9cef51b3538b7dce9787fd88d223312a2a8a7da3f4eadb48.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Steppers-control-with-Microstepping-intermediate-current-levels-on-the-motors-coils.png)

For example, if we select quarter-step resolution, the 200 steps of the motor will become, 200 multiplied by 4 equals 800 microsteps per revolution. The driver will use four different current levels on the coils to achieve this. 

The A4988 driver has a maximum resolution of 16 microsteps, which would make a 200 steps NEMA17 motor has 3200 steps per revolution, or that’s 0.1125 degrees per step. That’s really impressive precision and that’s why these types of stepper motors and drivers are used in so many applications. Actually, there are stepper drivers that have up 256 microsteps, or that’s a whopping 51200 steps per revolution, or 0.007 degrees per step.

Nevertheless, these three pins have pull-down resistors, so if we leave them disconnected, the driver will work in full-step mode. For selecting a different mircrostepping resolution we need to connect 5V to the appropriate pins according to this table. 

### A4988 Current Limiting

All right, so now that we know how to connect the stepper motor and the driver to the Arduino board, we can move on with explaining how to program or code the Arduino for controlling the stepper. However, before we do that, or before we power the motor, there is one more very important thing that we need to do, and that’s to adjust the current limit of the driver.

As we already explained, we need to adjust the current limit of the driver to be lower than the current rating of the motor, or otherwise the motor would overheat.

[![](assets/img/6/7/8/67827386ae9536df9e16b5bdbccb2a6cd47b0e2b60d9d0d6ce18dc93e7442292.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Setting-the-A4988-current-limit-by-measuring-the-reference-voltage.jpg)

There’s a small trimmer potentiometer on the A4988 driver though which we can adjust the current limit. By rotating the potentiometer clockwise, the current limit raises, and vice versa. There are two methods which can be used for determining the actual value of the current limit. 

The first method involves measuring the reference voltage across the potentiometer itself and GND. We can measure the reference voltage using a multimeter, and use that value in the following formula to calculate the current limit of the driver:

**_Current Limit = Vref / (8 x Rcs)_**

The Rcs is the current sense resistance or the values of the current sensing resistors located right next to the chip. Depending on the manufacturer, these values are usually 0.05, 0.1 or 0.2 ohms. So, we need to take a closer look at the value of these resistors in order to accurately calculate the current limit with this method. In my case, these resistors were labeled R100, which meant 0.1ohms.

[![](assets/img/4/5/6/456dfd9c2170b319fde863a3bf6220fde03558aeed9fbe26d90be92345c255cb.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/A4988-stepper-driver-current-sensing-resistors-for-calculating-the-current-limit-using-the-voltage-reference.jpg)

As an example, if we measure a reference voltage of 0.7V, and we have 0.1 ohms resistors, the current limit would be a 0.875A. Or if we want to limit the current to, let’s say 1A, we should adjust the reference voltage to 0.8V. 

The second method for setting the current limit is by directly measure the current through the coils. For that purpose, we need to connect the stepper motor and the driver as explained previously. We can skip the controller connection, but instead connect 5V to the Direction and the Step pins so that the motor stays active and holds one position. The MS pins should be left disconnected so the driver would work in full-step mode. Then we can disconnect one line or coil from the motor, and connect it in series with an ammeter. In this way, once we power the driver with both the logic voltage, the 5V, and the power for the motor 12V in my case, we can read how much current is running through the coil.

![](assets/img/9/c/6/9c67b09577dd6bbf67fd1150e4370b3c9aadda04c74b6a6095051fe970e9cb27.webp)

Though, we should note here that when the driver works in full-step mode, the current in the coils can reach only 70% of the actually current limit. So, when using the driver in the other microstepping modes, the reading from the ammeter should be multiplied by 1.3 in order to get the actual value of the current limit of the driver. 

I tried both methods for setting up the current limit of the driver and they gave me approximately the same results.

## Stepper Motors and Arduino – Example Codes

Nevertheless, now we can move on with programming the Arduino, or take a look at several example codes for controlling a stepper motor with an Arduino board.

![](assets/img/d/c/9/dc9b8b3fe5e6546286c8d3571261d25033f1355c0f384e267d0a984599cf09b6.webp)

Let’s start with a very basic example code of how to control a stepper motor without using a library.

**Example code 1**

```
/*   
 *   Basic example code for controlling a stepper without library
 *      
 *   by Dejan, https://howtomechatronics.com
 */

// defines pins
#define stepPin 2
#define dirPin 5 
 
void setup() {
  // Sets the two pins as Outputs
  pinMode(stepPin,OUTPUT); 
  pinMode(dirPin,OUTPUT);
}
void loop() {
  digitalWrite(dirPin,HIGH); // Enables the motor to move in a particular direction
  // Makes 200 pulses for making one full cycle rotation
  for(int x = 0; x < 800; x++) {
    digitalWrite(stepPin,HIGH); 
    delayMicroseconds(700);    // by changing this time delay between the steps we can change the rotation speed
    digitalWrite(stepPin,LOW); 
    delayMicroseconds(700); 
  }
  delay(1000); // One second delay
  
  digitalWrite(dirPin,LOW); //Changes the rotations direction
  // Makes 400 pulses for making two full cycle rotation
  for(int x = 0; x < 1600; x++) {
    digitalWrite(stepPin,HIGH);
    delayMicroseconds(500);
    digitalWrite(stepPin,LOW);
    delayMicroseconds(500);
  }
  delay(1000);
}Code language: Arduino (arduino)
```

**Code description:**

Here all we have to do is define to which pin number the STEP and DIR pins are connected and define them as outputs. In the loop, first we set the rotation direction of the motor by making the Direction pin status HIGH. Then using a “for” loop we send 200 pulses to the STEP pin which will make the motor rotate a full cycle, considering that it works in full-step mode. The pulses are generated simply by toggling the state of the STEP pin HIGH to LOW with some time delay between them. This time delay actually defines the speed of rotation. If we lower it, the speed of rotation will increase as the steps will occur faster, and vice versa. 

Then we change the rotation direction, and using another “for” loop we send 400 pulses which would make to motor rotate two full cycles. However, if we change the microstepping mode of the driver, let’s say so a quarter-step, which would make the motor have 800 steps now, the first loop will make the motor rotate only 90 degrees, and the second loop only half rotation.

**Example code 2**

Here’s another simple example, controlling the stepper motor speed using a potentiometer.

[![](assets/img/e/1/9/e19ee224862fb7c9507ae7840390878913c4c5579e8fcd6e5d416768df0e5e32.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Controlling-stepper-motor-speed-with-potentiometer-Wiring-diagram.png)

For that purpose, just have to connect the potentiometer to the Arduino and read its value using the analogRead() function.

```
/*
     Basic example code for controlling a stepper without library

     by Dejan, https://howtomechatronics.com
*/

// defines pins
#define stepPin 2
#define dirPin 5

int customDelay, customDelayMapped;

void setup() {
  // Sets the two pins as Outputs
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
}
void loop() {
  speedControl();
  // Makes pules with custom delay, depending on the Potentiometer, from which the speed of the motor depends
  digitalWrite(stepPin, HIGH);
  delayMicroseconds(customDelayMapped);
  digitalWrite(stepPin, LOW);
  delayMicroseconds(customDelayMapped);
}
// Custom function for reading the potentiometer and mapping its value from 300 to 3000, suitable for the custom delay value in microseconds
void speedControl() {
  customDelay = analogRead(A0); // Read the potentiometer value
  customDelayMapped = map(customDelay, 0, 1023, 300, 3000); // Convert the analog input from 0 to 1024, to 300 to 3000
}Code language: Arduino (arduino)
```

**Code description:**

We can then map or convert the potentiometer values which are from 0 to 1023, to values suitable for being a delay time in microseconds for the Step pulses. I found the minimum value for the delay between steps to be around 300 microseconds. By going lower that that the stepper motor started skipping steps. 

Overall, controlling stepper motors with this method is easy and it works, but only if the required control is simple as shown in the examples. In case we need more complex control, the best way is to use an Arduino library.

## Controlling Stepper Motors with Arduino and the AccelStepper Library – Examples

The most popular library for controlling stepper motors with Arduino is the [AccelStepper library by Mike McCauley](https://www.airspayce.com/mikem/arduino/AccelStepper/). It’s an extremely versatile library featuring speed, acceleration and deceleration control, setting target positions, controlling multiple stepper motors simultaneously and so on.

The library has a great documentation explaining how each function work. I have already used this library for several of my Arduino projects, for controlling the motion of my [DIY Camera Slider](https://howtomechatronics.com/tutorials/arduino/diy-motorized-camera-slider-pan-tilt-head-project/), the [3D wire bending machine](https://howtomechatronics.com/projects/arduino-3d-wire-bending-machine/), the [SCARA robot arm](https://howtomechatronics.com/projects/scara-robot-how-to-build-your-own-arduino-based-robot/) and few others. In case you are interested, there are details and code explanations for each project on the website. 

Now let’s take a look at few examples code using this library.

### Example code – Stepper motor speed control using a potentiometer

The first example will be controlling the speed of the motor using the potentiometer.

```
/*   
 *   Basic example code for controlling a stepper with the AccelStepper library
 *      
 *   by Dejan, https://howtomechatronics.com
 */

#include <AccelStepper.h>

// Define the stepper motor and the pins that is connected to
AccelStepper stepper1(1, 2, 5); // (Type of driver: with 2 pins, STEP, DIR)

void setup() {
  // Set maximum speed value for the stepper
  stepper1.setMaxSpeed(1000);
}

void loop() {
  stepper1.setSpeed((analogRead(A0));
  // Step the motor with a constant speed previously set by setSpeed();
  stepper1.runSpeed();
}Code language: Arduino (arduino)
```

**Code description:**

So, here first we need to include the AccelStepper library. Of course, before we do that, we need to install the library and we can do that from the Arduino IDE library manager. We just have to search “AccelStepper” and the library will show up and we can install it. 

Then, we need to create an instance of the AccelStepper class for our motor. The first parameter here is the type of driver, in this case for a driver with two control pins this value is 1, and the other two parameters are the pin numbers to which our driver is connect to the Arduino. If we have multiple stepper motors, we need to define each of them like this, and we can name them however we want, in this case I named my motor stepper1. 

In the setup section we just have to set the maximum speed of the motor which is defined as steps per second. This value can go up to 4000, but in the documentation of the library it is stated that speed values of more than 1000 steps per seconds might be unreliable. 

In the loop section, using the setSpeed() function we set the current speed of the motor, and in this case that’s the analog input from the potentiometer which is from 0 to 1023.

In order the motor to move and implement that constant speed, we need to call the runSpeed() function each interval. A negative value here, or simply including a minus sign before the value, would make the stepper motor rotate in the opposite direction.

### Example code – Controlling two stepper motors with acceleration and deceleration

![Controlling two stepper motors with acceleration and deceleration](assets/img/9/0/e/90e95724437c85ca66f3c850586c75cefed18174b0210e02f45b11d4abb87f82.webp)

Here’s another example of controlling two stepper motors with implementing acceleration and deceleration using the AccelStepper library.

```
/*
    Controlling two stepper with the AccelStepper library

     by Dejan, https://howtomechatronics.com
*/

#include <AccelStepper.h>

// Define the stepper motor and the pins that is connected to
AccelStepper stepper1(1, 2, 5); // (Typeof driver: with 2 pins, STEP, DIR)
AccelStepper stepper2(1, 3, 6);

void setup() {

  stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper
  stepper1.setAcceleration(500); // Set acceleration value for the stepper
  stepper1.setCurrentPosition(0); // Set the current position to 0 steps

  stepper2.setMaxSpeed(1000);
  stepper2.setAcceleration(500);
  stepper2.setCurrentPosition(0);
}

void loop() {

  stepper1.moveTo(800); // Set desired move: 800 steps (in quater-step resolution that's one rotation)
  stepper1.runToPosition(); // Moves the motor to target position w/ acceleration/ deceleration and it blocks until is in position

  stepper2.moveTo(1600);
  stepper2.runToPosition();

  // Move back to position 0, using run() which is non-blocking - both motors will move at the same time
  stepper1.moveTo(0);
  stepper2.moveTo(0);
  while (stepper1.currentPosition() != 0 || stepper2.currentPosition() != 0) {
    stepper1.run();  // Move or step the motor implementing accelerations and decelerations to achieve the target position. Non-blocking function
    stepper2.run();
    //
    //
  }
}Code language: Arduino (arduino)
```

**Code description:**

So, we need to define the two stepper motors, and in the setup, using the setAcceleration() function set the acceleration value for the motors. Using the setCurrentPosition() function we set the position of the motors to be at 0 steps. 

In the loop section, we start with the moveTo() function through which we tell the motor to what position to go or how many steps it should move. In case of quarter-step resolution, 800 steps would mean one full rotation. Then, the runToPosition() function moves the motor to that position while implementing acceleration and deceleration. However, this is a blocking function, so the code execution will stay there until the stepper motor reaches that position. 

With the same method we move the second motor 1600 steps or two full rotations with quarter-step resolution. 

If we don’t want our code to be blocked until the motor reach the target position, instead of using the runToPosition() function, we should use the run() function. The run() also implements acceleration and deceleration to achieve the target position, but it just makes one step per call. Therefore, we need to call it as frequently as possible. For that reason, here we put the run() functions for both motors in this while loop, which is executed until both steppers reach position 0. We previously set the two motors to go to position 0 with the moveTo() functions. 

We could also add more code in that “while” loop and do other stuff too along running the motor. Actually, there are many methods of running the motors and doing other stuff too. I recommend going through the nicely described documentation of the library so you can understand how each function works and implement them according to your needs.

### Example code – Controlling multiple stepper motors with AccelStepper library

I would like to show you one more example using the AccelStepper library and that’s controlling multiple stepper motors in a coordinated fashion. This means, we can set target positions for each stepper and they can reach their positions all at the same time, no matter the different distance they need to travel.

[![](assets/img/0/f/5/0f5d444973e1f201c7934a37f0435094f5b582961bd4520c31a4a2a0dd7aafd5.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Controlling-multiple-stepper-motors-with-AccelStepper-library.jpg)

This can be easily done using the MultiStepper class that comes with the AccelStepper library.

```
/*
    Controlling multiple steppers with the AccelStepper and MultiStepper library

     by Dejan, https://howtomechatronics.com
*/

#include <AccelStepper.h>
#include <MultiStepper.h>

// Define the stepper motor and the pins that is connected to
AccelStepper stepper1(1, 2, 5); // (Typeof driver: with 2 pins, STEP, DIR)
AccelStepper stepper2(1, 3, 6);
AccelStepper stepper3(1, 4, 7);

MultiStepper steppersControl;  // Create instance of MultiStepper

long gotoposition[3]; // An array to store the target positions for each stepper motor

void setup() {

  stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper
  stepper2.setMaxSpeed(1000);
  stepper3.setMaxSpeed(1000);

  // Adding the 3 steppers to the steppersControl instance for multi stepper control
  steppersControl.addStepper(stepper1);
  steppersControl.addStepper(stepper2);
  steppersControl.addStepper(stepper3);
}

void loop() {
  // Store the target positions in the "gotopostion" array
  gotoposition[0] = 800;  // 800 steps - full rotation with quater-step resolution
  gotoposition[1] = 1600;
  gotoposition[2] = 3200;

  steppersControl.moveTo(gotoposition); // Calculates the required speed for all motors
  steppersControl.runSpeedToPosition(); // Blocks until all steppers are in position

  delay(1000);

  gotoposition[0] = 0;
  gotoposition[1] = 0;
  gotoposition[2] = 0;

  steppersControl.moveTo(gotoposition);
  steppersControl.runSpeedToPosition();

  delay(1000);
}Code language: Arduino (arduino)
```

**Code description:**

Here we also need to include the MultiStepper class, and create an instance of it. Then we need to define an array, type “long”, which will be used for storing the target positions for our motors. In the setup section, we need to define the maximum speed values of the steppers and add the steppers to the previously created MultiStepper instance, which in my case I named it “steppersControl”. 

In the loop section, we start by storing the target position values in the array that we previously created. I set the first stepper to move one rotation, the second, two rotations and the third one, three rotations. Then we can assign this array to the moveTo() function which will calculate the required speeds for all motors to arrive at those positions at the same time. Then we just have to call the runSpeedToPosition() function which will move the motors to their position. Though we should note that this function blocks the code until the steppers reach their target position. We could use the run() function instead, if we don’t want to block the code. We should also note that the MultiStepper class doesn’t support acceleration and deceleration. 

Nevertheless, if you want to learn more, from more advanced examples, you can check my Arduino projects that I already mentioned, all the details and the codes for them are on the website.

## CNC shield for controlling multiple stepper motors for any Arduino project

Still taking about controlling multiple stepper motors, it’s worth mentioning and taking a look at the Arduino CNC shield.

[![](assets/img/0/f/f/0ff2089762c823551a1839195d6dca0f607b69d24d038a267289f9cd98e5ecac.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/CNC-Shield-for-controlling-multiple-stepper-motors-for-any-Arduino-project.jpg)

The main purpose of the Arduino CNC shield is for controlling 2 or 3-axis CNC machines, but it is actually a great option for controlling any type of project where we need to control multiple stepper motors as it is compact and provides easy connections for the drivers and the motors. 

This shield goes on top of an Arduino UNO board, and can control up to 4 individual stepper motors, and have all the remaining Arduino pins available for use. I used this combination of an Arduino UNO board and the CNC shield for controlling my [4-axis SCARA robot arm](https://howtomechatronics.com/projects/scara-robot-how-to-build-your-own-arduino-based-robot/).

I will update this section of the article, how to use the CNC shield with Arduino with more details soon.

## DRV8825 vs A4988

All right, so now let’s move on and see how we can control stepper motors using the other driver that I mentioned at the beginning, the DRV8825.

Actually, everything we explained so far about controlling stepper motors with the A4988 stepper driver, applies for the DRV8825 as well. The working principle, the connections and the coding are almost the same for both of these drivers. The difference between them is in their technical characteristics and now we will take a look at them and compare them.

[![DRV8825 vs A4988](assets/img/9/2/f/92fc6c9d12050c487acddec179bb798556831535af7befd96304cf395a305968.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/DRV8825-vs-A4988-stepper-drivers.jpg)

The DRV8825 is a stepper driver by Texas Instruments which can be used as direct replacement for the Allegro A4988 driver as their connections are the same. The three key differences between them are that the DR8825 can deliver more current than the A4988 without additional cooling (1.5A vs 1A), it has higher maximum supply voltage (45V vs 35V), and it offers higher microstepping resolution (32 vs 16 microsteps). 

Of course, they also have some other minor differences. For example, the current limit potentiometer has a different location and the relationship between the current limit setting and the reference pin voltage is different. The DRV8825 doesn’t need logic power supply, and the that pin location is used as FAULT output.

[![](assets/img/4/f/d/4fdb72689961006646fa3be3fbeaabd82b5bd7862bf9c0c2287947e8b801d521.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/DRV8825-vs-A4988-pinout.png)

However, it is safe to connect the FAULT pin directly to 5V, so the DRV8825 can be used as a direct replacement in systems designed for the A4988 driver. 

It’s worth noting though, that when replacing an A4988 driver with an DRV8825 it is very important to make sure the orientation of the driver is correct. I already mentioned, their potentiometers are at different locations, on the A4988 it’s below the chip, and on the DRV8825 is above the chip, and that can sometimes cause confusion and the driver can be easily placed on the wrong side. 

For setting the current limit, we can measure the reference voltage with one probe on GND and the other on the potentiometer itself.

[![Adjusting the current limit of the DRV8825 stepper driver](assets/img/6/8/a/68a5c0abd32c183b93b3058734a9d94881eea3d6f8cd0e070fb2868eae666aba.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/Adjusting-the-current-limit-of-the-DRV8825-stepper-driver.jpg)

The formula for calculating for the DRV8825 stepper drive is as follow:

**_Current limit = Vref x 2_**

As for selecting the microstepping resolution, we can use the following table.

![](assets/img/2/9/9/299b7c288e3fae9be66eabb01c55fa14284ddd470a7686ff8216e19e00476ad6.webp)

Overall, the DRV8825 is a better stepper driver than the A4988, as it offers higher current and voltage ratings, and higher microstepping resolution which results in smoother and quieter operation of the stepper motor.

## TMC2208 Stepper Driver

Speaking of smoother and quieter operation, let’s take a look at the TMC2208 stepper driver. The TMC2208 chip is made by Trinamic, a Germany based company specialized in motion control electronics. The TMC2208 is a silent stepper motor driver which can be also used as a direct replacement in systems designed for the A4988 or the DRV8825 drivers. It is widely used in desktop 3D printers, laser engravers, scanners and so on.

[![TMC2208 vs A4988 vs DRV8825 stepper motor drivers](assets/img/8/5/6/85679ac9647f55dca7480cd5084ab3db263090417f7867ed0a766da5c7797332.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/TMC2208-vs-A4988-vs-DRV8825-stepper-motor-drivers.jpg)

What sets this driver apart from the two others is its integrated interpolation unit which provides 256 subdivisions or microsteps. This allows for perfect sinusoidal control which is generated internally within the chip. This means that the driver will output 256 microsteps to the stepper motor, no matter what microstep resolution we have selected through the two MS pins, 2, 4, 8 or 16 microsteps. This provides smoother operation and reduces the burden of the microcontroller significantly.

[![](assets/img/3/b/b/3bb6d25566b4600528ae19a4b87513db48b8d628e1e0bb065d4984b6dfc29ddb.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/TMC2208-256-subdivisions-or-microsteps-with-integrated-interpolation-from-2-4-8-or-16-microsteps.jpg)

This feature of the driver, in combination with the its noiseless current control StealthChop2 technology, provide that ultra-silent control of the stepper motors. Here’s a comparison of the noise levels between the three drivers.

[![TMC2208 vs A4988 vs DRV8825 Noise Levels Comparison](assets/img/0/f/5/0f55e4b9d55374ff4bbfffedd2b77afd908c68a2f7662d710d4bd3289288e32c.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/TMC2208-vs-A4988-vs-DRV8825-Noise-Levels-Comparison.jpg)

**Stepper driver noise levels:** A4988 around 65dB, DRV8825 around 67dB and TMC2208 around 41dB.

The TMC2208 drives the stepper motors completely silently, which is really impressive.

The current rating of the TMC2208 is slightly higher than the A4988 driver, or it’s 1.2A with 2A peak current. For setting the current limit of the driver, again we can use the same method as explained for the other drivers. We need to measure the reference voltage with one probe on GND, and other on the whole right next to the Enable pin.

[![TMC2208 current limiting by measuring the reference voltage](assets/img/0/3/d/03d7179df6e1a891485f9f268e944007ea609104f8edd32c910add1ddbf2dd43.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/TMC2208-current-limiting-by-measuring-the-reference-voltage.png)

The formula for calculating the current limit is as follow:

**_Current limit = Vref x 0.71_**

Although it can be used as direct replacement, the TMC2208 driver has a slightly different pinout compared to the A4988 driver. Here we only have two pins for selecting the microsteps resolution and for enabling the driver we need to connect the Enable pin to GND.

[![TMC2208 and Arduino Connection - Wiring diagram and microstepping table](assets/img/f/6/e/f6e3e6e37943907d5c1537e3d9f39d2855042e28fc566663b4b8091e49ca1659.webp)](https://howtomechatronics.com/wp-content/uploads/2022/05/TMC2208-and-Arduino-Connection-Wiring-diagram-and-microstepping-table.png)

In terms of coding, it’s the same as the other two drivers. 

The TMC2208 driver also have some other, more advanced features compared to the two other drivers, like for example, a simple-to-use UART interface which provides controlling the driver with just a single line, instead of the two Step and Dir pins. In addition to that I provides more tuning and control options. 

Overall, the TMC2208 is a better driver that the A4988 and the DRV8825, but that’s normal as it comes with a higher price tag. Though, if you don’t need these extra features and the noise levels doesn’t concern you, are other two drivers are just great choice.

### 2、步进驱动器的接线及设置

目前市场上有很多步进驱动器，各厂家的驱动器具有类似的接口，都有信号、电源、电机等接线端子；有输出电流及细分驱动设置的拨码开关。本节以雷赛科技（LeadShine）的DM542步进驱动器为例，介绍下步进驱动器的接线及设置。

DM542是雷赛公司推出的两相步进电机驱动器，采用脉冲方式进行控制，支持8档位电流及16档位细分驱动；输入电压范围：DC 20V~50V，输出峰值电流范围：1.0~4.2A；下面这张图是DM542的外观图：

![leisai_DM542.png](https://www.founderchip.com/zb_users/upload/2020/01/20200120165509_79003.png "leisai_DM542.png")

从图片中可以看出，DM542步进驱动器包括控制信号端子、电源端子、电机接线端子、输出电流设置和细分驱动设置拨码开关等几部分组成。

**2.1、控制信号端子**

控制信号端子与PLC、单片机或其它控制器相连接，用来接收控制器发出的脉冲、方向及使能控制信号。

2.1.1、脉冲信号（Pulse）

脉冲信号有两个接线端子：PUL+和PUL-。"PUL+"连接脉冲信号正极，“PUL-”连接脉冲信号负极；脉冲信号以"PUL+"与"PUL-"的电压差来衡量；拨码开关SW13可设置脉冲的有效沿，默认（SW13=OFF）上升沿有效；

2.1.2、方向信号（Direction）

方向信号有两个接线端子：DIR+和DIR-。"DIR+"连接方向信号正极，"DIR-"连接方向信号负极；步进电机的初始运行方向与电机绕组的接线有关，任何一组绕组互换（比如：A+和A-互换）都能改变电机的初始运行方向；电机在运行过程中的方向改变可以通过方向信号来控制，为了保证步进电机可靠换向，方向信号应早于脉冲信号至少5us建立；

2.1.3、使能信号（Enable）

使能信号用于使能或禁止驱动器输出，有两个接线端子：ENA+和ENA-。"ENA+"连接使能信号正极，"ENA-"连接使能信号负极；当"ENA+"信号接通时，驱动器将切断步进电机各相电源而使其处于自由状态，该状态不响应脉冲信号；

注：脉冲信号、方向信号和使能信号输入电压值的大小可通过滑动开关来设置，有DC 5V和DC 24V两种选择，出厂默认DC 24V；

2.1.4、报警信号（Alarm）

驱动器故障信号输出，用于连接到PLC/控制器的输入通道。出厂默认正常情况下ALM和COM是导通状态，当驱动器报警时为截止状态；可通过拨码开关SW12设置；

2.1.4、抱闸信号（Brake）：步进电机的抱闸信号输入；

2.1.5、COM：报警信号和抱闸信号的公共端；

**2.2、电源接口**

电源接口包括2个接线端子：+Vdc、GND，其中：

+Vdc：直流电源正极，电压范围：+20V~+50V，推荐+24V~+48V；

GND：直流电源负极；

**2.3、电机接线端子**

电机接线端子包括：A+、A-、B+、B-，其中：

A+和A-是步进电机的A相绕组的两个接线柱；

B+和B-是步进电机的B相绕组的两个接线柱；

下面这张图是步进电机驱动器的接线图：

![步进驱动器接线图.png](https://www.founderchip.com/zb_users/upload/2020/01/20200120165509_64056.png "步进驱动器接线图.png")

### **2.4、步进电机的电流设置**

DM542步进驱动器的中间有8个拨码开关（SW1~SW8），其中SW1~SW3用来设置工作电流（动态电流）；SW4用来设置静止电流（静态电流）；SW5~SW8是细分设置（将在第3小节详细介绍）；

**2.4.1、工作电流设置**

通过设置步进驱动器的电流输出拨码开关，可以改变驱动器的输出电流大小。DM542的SW1~SW3拨码开关设置如下图所示：

![sw1_sw3.png](https://www.founderchip.com/zb_users/upload/2020/01/20200120165509_42724.png "sw1_sw3.png")

当步进驱动器设置的输出电流越大时，其连接的步进电机的输出力矩就越大。但是电流过大会导致电机和驱动器发热，严重时可能会损坏电机或驱动器。因此在设置步进驱动器的电流时建议遵循如下原则：

-   四线电机：设置输出电流等于或略小于电机的额定电流；
    
-   六线电机高力矩模式：设置输出电流等于电机单极性接法额定电流的50%；
    
-   六线电机高速模式：设置输出电流等于电机单极性接法额定电流的100%；
    

举个例子：假设要用DM542驱动雷赛42CM06步进电机，该电机的额定电流为2.5A，我们就采用输出均值电流2.36A的档位，设置SW1=OFF，SW2=ON，SW3=OFF；

另外要注意：步进电机的运动类型及停留时间的长短，都会影响其发热量。因此在实际使用中应视电机的发热情况适当调节输出电流的大小。原则上如果电机运行15~30分钟后如果表面温度低于40度，可适当增加电流设置值以增大输出扭矩；但如果温升太高（>70度），则应降低电流的设置值；

**2.4.2、静止电流设置**

拨码开关SW4可用于设置步进电机在静止状态时驱动器的输出电流。默认情况下SW4=OFF，它表示驱动器在没有接收到脉冲0.4秒后，将输出电流改变为峰值电流的50%，这样可以降低驱动器和电机的发热；如果将SW4设置为ON，则电机在静止状态下，驱动器的输出电流为其峰值电流的90%；

### 3、细分驱动设置

**3.1、什么是细分驱动？**

步进电机在出厂时都标注了“固有步距角”。比如某电机的固有步距角为0.9度/1.8度，表示电机半步工作每次会转过0.9度，整步1.8度。在很多精密控制的场合，固有步距角不能满足控制精度的要求，人们希望能将一个固有步距角分很多步来走完。这种将固有步距角再分成很多步的驱动方法，称为"细分驱动"。能实现细分驱动的驱动器，称为"细分驱动器"。

**3.2、细分驱动的优点**

-   细分驱动将固有步距角平均分成几份，减少了每步的步距角的大小，提高了步距均匀度，提高了控制精度；
    
-   低频振荡是步进电机的固有特性，细分驱动提高了电机的转动频率，可以降低电机的振动；
    
-   细分驱动可以有效减少转矩波动，提高输出转矩；
    

**3.4、细分驱动的设置**

以DM542为例，该驱动器提供了四个拨码开关（SW5~SW8）用来设置细分驱动，如下图所示：

![sw5_sw8.png](https://www.founderchip.com/zb_users/upload/2020/01/20200120165509_65889.png "sw5_sw8.png")

假设我们要把电机设置为3200步/转（即每转一圈需要3200个脉冲信号），则拨码开关设置如下：SW5=ON，SW6=ON，SW7=OFF，SW8=ON  

~~~ C
#include <AccelStepper.h>

// Define the stepper motor and the pins that is connected to
AccelStepper stepper1(1, 3, 7); // (Typeof driver: with 2 pins, STEP, DIR)

void setup() {
  Serial.begin(9600);
  stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper
  stepper1.setAcceleration(500); // Set acceleration value for the stepper
  stepper1.setCurrentPosition(0); // Set the current position to 0 steps
}

void loop() {
  if (Serial.available() > 0) {
    String incomingString = Serial.readStringUntil('\n'); // Read until the "Enter" button is pressed
    incomingString.trim(); // Remove leading/trailing whitespaces
    if (incomingString == "lift") {
      Serial.println("Moving down");
      stepper1.moveTo(15000); // Set desired move: 15000 steps
      stepper1.runToPosition(); // Moves the motor to target position
    } else if (incomingString == "back") {
      Serial.println("Moving back to original position");
      stepper1.moveTo(0);
      stepper1.runToPosition();
    }
  }
}

~~~




Sure, here's an example Arduino sketch that reads a string from the serial port and prints it to the Serial Monitor:

```
arduinovoid setup() {
  // initialize serial communication at 9600 baud rate
  Serial.begin(9600);
}

void loop() {
  if (Serial.available() > 0) {
    // read the incoming string and store it in a variable
    String incomingString = Serial.readString();
    
    // print the incoming string to the Serial Monitor
    Serial.println(incomingString);
  }
}

```

This code listens for incoming data on the serial port, and when data is available, it reads the string and stores it in a variable. It then prints the incoming string to the Serial Monitor, allowing you to see the text data that is being sent from your Python program or other serial device. Note that `Serial.readString()` will read all the characters in the serial buffer until it reaches a newline character (`\n`) or the timeout period expires. So, make sure to send your string with a newline character at the end or adjust the timeout value, if necessary.

![killer LB](https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAEdFTp4JmUpX3g9eCc8g_mWlzi2zUqL2P0yb2DvzqoEBdQ%3Ds96-c&w=64&q=75)

/\* Controlling two stepper with the AccelStepper library by Dejan, https://howtomechatronics.com \*/ #include <AccelStepper.h> // Define the stepper motor and the pins that is connected to AccelStepper stepper1(1, 3, 7); // (Typeof driver: with 2 pins, STEP, DIR) void setup() { Serial.begin(9600); stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper stepper1.setAcceleration(500); // Set acceleration value for the stepper stepper1.setCurrentPosition(0); // Set the current position to 0 steps } void loop() { if (Serial.available()>0){ String incomingString = Serial.readString(); if (incomingString == 'drop') { Serial.print("success run into drop mode"); stepper1.moveTo(15000); // Set desired move: 800 steps (in quater-step resolution that's one rotation) stepper1.runToPosition(); // Moves the motor to target position w/ acceleration/ deceleration and it blocks until is in position } //print the incoming string to the Serial Monitor if (incomingString == 'back') { Serial.print("Backing into original position "); stepper1.moveTo(0); stepper1.runToPosition(); } } } check this code, I want to achieve the motor move down 15000 when I type in "lift" and back to the original position when I type"back"

![killer LB](https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAEdFTp4JmUpX3g9eCc8g_mWlzi2zUqL2P0yb2DvzqoEBdQ%3Ds96-c&w=64&q=75)

I want to achieve the motor move down 15000 when I type in "lift" and back to the original position when I type"back"

I'm sorry, I made a mistake in my previous response. Here's the corrected code:

```
arduino#include <AccelStepper.h>

// Define the stepper motor and the pins that it is connected to
AccelStepper stepper1(1, 3, 7); // (Type of driver: with 2 pins, STEP, DIR)

void setup() {
  Serial.begin(9600);
  stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper
  stepper1.setAcceleration(500); // Set acceleration value for the stepper
  stepper1.setCurrentPosition(0); // Set the current position to 0 steps
}

void loop() {
  if (Serial.available() > 0) {
    String incomingString = Serial.readString();
    if (incomingString == "lift") {
      Serial.println("Moving down 15000 steps");
      stepper1.moveTo(15000); // Set desired move: 15000 steps
      stepper1.runToPosition(); // Moves the motor to target position with acceleration/deceleration and blocks until it is in position
    }
    else if (incomingString == "back") {
      Serial.println("Moving back to original position");
      stepper1.moveTo(0); // Set desired move: 0 steps (back to original position)
      stepper1.runToPosition(); // Moves the motor to target position with acceleration/deceleration and blocks until it is in position
    }
  }
}

```

This code listens for incoming data on the serial port, and when data is available, it reads the string and stores it in a variable. It then checks if the incoming string is equal to "lift" or "back", and if it is, it sets the desired move for the stepper motor and calls `runToPosition()` to move the motor to the target position. Note that the `moveTo()` function sets the absolute position for the motor, so you don't need to keep track of the current position manually. Also, make sure to enclose the string values in double quotes, not single quotes.

    

If none of these suggestions work, please provide more information about the issue you are facing, including any error messages or symptoms you are observing.

![killer LB](https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAEdFTp4JmUpX3g9eCc8g_mWlzi2zUqL2P0yb2DvzqoEBdQ%3Ds96-c&w=64&q=75)

Hardware work properly but When I type"lift" the code failed to make a judge

It looks like there might be a problem with the `if` statements in your `loop()` function. The `if` statements are checking for a character instead of a string. Here's the corrected code:

```
scss#include <AccelStepper.h>

// Define the stepper motor and the pins that is connected to
AccelStepper stepper1(1, 3, 7); // (Typeof driver: with 2 pins, STEP, DIR)

void setup() {
  Serial.begin(9600);
  stepper1.setMaxSpeed(1000); // Set maximum speed value for the stepper
  stepper1.setAcceleration(500); // Set acceleration value for the stepper
  stepper1.setCurrentPosition(0); // Set the current position to 0 steps
}

void loop() {
  if (Serial.available() > 0) {
    String incomingString = Serial.readString();
    if (incomingString == "lift") {
      Serial.println("Moving down");
      stepper1.moveTo(15000); // Set desired move: 15000 steps
      stepper1.runToPosition(); // Moves the motor to target position
    } else if (incomingString == "back") {
      Serial.println("Moving back to original position");
      stepper1.moveTo(0);
      stepper1.runToPosition();
    }
  }
}

```

The corrected code checks for a string input using double quotes (`"`) instead of a character input using single quotes (`'`). The `Serial.println()` function is also used instead of `Serial.print()` to add a line break after the text message.



![killer LB](https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAEdFTp4JmUpX3g9eCc8g_mWlzi2zUqL2P0yb2DvzqoEBdQ%3Ds96-c&w=64&q=75)

ser.write(b'100\\n') what is b's function

In Python, the `b` prefix before a string literal creates a bytes object rather than a regular string object. Bytes objects are similar to string objects, but they represent a sequence of bytes rather than a sequence of characters.

In the line `ser.write(b'100\n')`, the `b` prefix is used to create a bytes object containing the string "100\\n". The `write()` method of a serial object expects a bytes object as input, so the `b` prefix is necessary to convert the string to bytes before it is sent over the serial port.

Without the `b` prefix, the `write()` method would expect a regular string object, and a `TypeError` would be raised when attempting to send the string over the serial port.

![killer LB](https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAEdFTp4JmUpX3g9eCc8g_mWlzi2zUqL2P0yb2DvzqoEBdQ%3Ds96-c&w=64&q=75)

`ser.read()` is a method in Python that reads a certain number of bytes from a serial port and returns them as a bytes object. It waits for incoming data to be available, then reads the specified number of bytes or until a timeout occurs.

If no argument is provided, `ser.read()` will read a single byte from the serial port. For example:

```
pythonimport serial

ser = serial.Serial('/dev/ttyACM0', 9600)

data = ser.read() # Read a single byte from the serial port

```

If an argument `size` is provided, `ser.read(size)` will read and return `size` bytes from the serial port. For example:

```
pythonimport serial

ser = serial.Serial('/dev/ttyACM0', 9600)

data = ser.read(10) # Read 10 bytes from the serial port

```

![killer LB](https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAEdFTp4JmUpX3g9eCc8g_mWlzi2zUqL2P0yb2DvzqoEBdQ%3Ds96-c&w=64&q=75)

how to read serial message by line in python

To read serial messages by line in Python, you can use the `readline()` method of a serial object. This method reads from the serial port until it encounters a newline character (`\n`) or carriage return (`\r`) and returns all the characters it read up to that point.

Here's an example code snippet that demonstrates how to use `readline()` to read serial messages by line:

```
pythonimport serial

ser = serial.Serial('/dev/ttyACM0', 9600)

while True:
    line = ser.readline()
    print(line)

```

In this example, the code creates a serial object for the port `/dev/ttyACM0` with a baud rate of 9600. It then enters an infinite loop and calls `readline()` on the serial object to read one line of text from the serial port. The code then prints the line to the console. The loop continues indefinitely, reading and printing lines from the serial port as they are received.

Note that `readline()` will block until it receives a full line of text, so the loop will pause until a full line is received. If the sender is not sending complete lines of text, you may need to modify the code to handle partial lines or use a different approach for reading from the serial port.


# How the Stepper Motor work 步进电机工作原理
In this tutorial article you will learn how a stepper motor works. We will cover the basic working principles of stepper motors, their driving modes and the steppers types by construction. You can watch the following video or read the written article.

  ![](assets/img/e/d/9/ed9f5a8665d48d971a2975263acc7af050d667d9657978d59fd10a7adecf543c.jpg)

## Working Principle

Stepper motor is a brushless DC motor that rotates in steps. This is very useful because it can be precisely positioned without any feedback sensor, which represents an open-loop controller. The stepper motor consists of a rotor that is generally a permanent magnet and it is surrounded by the windings of the stator. As we activate the windings step by step in a particular order and let a current flow through them they will magnetize the stator and make electromagnetic poles respectively that will cause propulsion to the motor. So that’ the basic working principle of the stepper motors.

### ![Working-Principle of Stepper Motor](assets/img/8/2/0/8205eec106324c6dbeac30870a3cbf2717add38f8074622f00ea084eb9b3f84d.webp)

## Driving Modes

There are several different ways of driving the stepper motor. The first one is the Wave Drive or Single-Coil Excitation. In this mode we active just one coil at a time which means that for this example of motor with 4 coils, the rotor will make full cycle in 4 steps.

![Wave-Drive Mode](assets/img/b/9/9/b9939002d37643d33418037cddd2b95c8a25d795d7e2dce487073a93b7074f6b.webp)

Next is the Full step drive mode which provides much higher torque output because we always have 2 active coils at a given time. However this doesn’t improve the resolution of the stepper and again the rotor will make a full cycle in 4 steps.

![Full-Step-Drive-Mode](assets/img/e/3/6/e361de10c768298bd73b483a9123801ed5cf56ab73758464c7714f6ddc6d35fb.webp)

For increasing the resolution of the stepper we use the Half Step Drive mode. This mode is actually a combination of the previous two modes.

Here we have one active coil followed by 2 active coils and then again one active coil followed by 2 active coils and so on. So with this mode we get double the resolution with the same construction. Now the rotor will make full cycle in 8 steps.

![Half-Step-Drive-Mode](assets/img/3/0/5/3058046e959a7f488eb90772af53690fd6b277055179f31c18a39e7a8827374f.webp)

However the most common method of [controlling stepper motors](https://howtomechatronics.com/tutorials/arduino/how-to-control-stepper-motor-with-a4988-driver-and-arduino/) nowadays is the Microstepping. In this mode we provide variable controlled current to the coils in form of sin wave. This will provide smooth motion of the rotor, decrease the stress of the parts and increase the accuracy of the stepper motor.

![Microstepping](assets/img/b/7/a/b7adab85b8dcd66d66d9104eb116d7e3051e4b848cec19b486d801fa804f4981.webp)

Another way of increasing the resolution of the stepper motor is by increasing the numbers of the poles of the rotor and the numbers of the pole of the stator.

![Incresing-Poles-Numbers0](assets/img/c/6/6/c6688d9d01156cc1cdd81bea4043c11921b7dad6d5be2ee92ca0effbbbde7f31.webp)

## Stepper Motor Types by Construction

![By-Construction](assets/img/4/9/1/491ebb04d7f325434d35ff8d0b872323cf0ea0f74273d6c88b0d230f76d22629.webp)

By construction there are 3 different types of stepper motors: permanent magnet stepper, variable reluctance stepper and hybrid synchronous stepper motor.  

The **Permanent Magnet** stepper has a permanent magnet rotor which is driven by the stators windings. They create opposite polarity poles compared to the poles of the rotor which propels the rotor.

![Stepper-Motor_PM](assets/img/8/3/5/835e64339869a28573a1ac901a9582ff8e1f77b198a4350a8e063062142252fd.webp)

The next type, the **Variable Reluctant** stepper motor uses a non-magnetizes soft iron rotor. The rotor has teeth that are offset from the stator and as we active the windings in a particular order the rotor moves respectively so that it has minimum gab between the stator and the teeth of the rotor

![Stepper-Motor-Variable-Reluctant01](assets/img/8/c/e/8ce93e32e1fbeca5e5cf931e7d54bd11cc158587d8277a4911c61ced82ded5ef.webp)

The **Hybrid Synchronous** motor is combinations of the previous two steppers. It has permanent magnet toothed rotor and also a toothed stator. The rotor has two sections, which are opposite in polarity and their teeth are offset as shown here.

![Top-View-Rotor01](assets/img/5/3/9/5394c41590225fbe3c38f45792bcc7b3bb5c02ad2d9c06ea8540aa0502780360.webp)

This is a front view of a commonly used hybrid stepper motor which has 8 poles on the stator that are activated by 2 windings, A and B. So if we activate the winding A, we will magnetize 4 poles of which two of them will have South polarity and two of them North polarity.

![Hybrid-Stepper-Motor02](assets/img/5/1/1/511f42953889fb208c178311e634f7d266ae2e2ab708cb1e2b611b8a3743339a.webp)

We can see that in such a way the rotors teeth are aligned with the teeth of poles A and unaligned with the teeth of the poles B. That means that in the next step when we turn off the A poles and activate the B poles, the rotor will move counter clock wise and its teeth will align with the teeth of the B poles.

![Hybrid-Stepper-Motor_Working-P](assets/img/f/7/8/f78daeff26514447538c8b9650e8eefeb46f56479872cd2fe9d5a8ada9f9b69e.webp)

If we keep activating the poles in a particular order the rotor will move continuously. Here we can also use different driving modes like the wave drive, full step drive, half step drive and microstepping for even further increasing the resolution of the stepper motor
## 步进电机基础知识

步进电机是一种通过步进（即以固定的角度移动）方式使轴旋转的电机。其内部构造使它无需传感器，通过简单的步数计算即可获知轴的确切角位置。这种特性使它适用于多种应用。
转载：[步进电机基础知识：类型、用途和工作原理|技术文章|MPS (monolithicpower.cn)](https://www.monolithicpower.cn/cn/stepper-motors-basics-types-uses)
## 步进电机工作原理

与所有电机一样，步进电机也包括固定部分（定子）和活动部分（转子）。定子上有缠绕了线圈的齿轮状突起，而转子为 [永磁体](https://www.monolithicpower.cn/cn/energy-recycling-in-dc-motor-drives)或可变磁阻铁芯。稍后我们将更深入地介绍不同的转子结构。图1显示的电机截面图，其转子为可变磁阻铁芯。

![Section of a Stepper Motor](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图1: 步进电机截面图

步进电机的基本工作原理为：给一个或多个定子相位通电，线圈中通过的电流会产生磁场，而转子会与该磁场对齐；依次给不同的相位施加电压，转子将旋转特定的角度并最终到达需要的位置。图2显示了其工作原理。首先，线圈A通电并产生磁场，转子与该磁场对齐；线圈B通电后，转子顺时针旋转60°以与新的磁场对齐；线圈C通电后也会出现同样的情况。下图中定子小齿的颜色指示出定子绕组产生的磁场方向。

![Stepper Motor Steps](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图2: 步进电机的步进

## 步进电机的类型与构造

步进电机的性能（无论是分辨率/步距、速度还是扭矩）都受构造细节的影响，同时，这些细节也可能会影响电机的控制方式。实际上，并非所有步进电机都具有相同的内部结构（或构造），因为不同电机的转子和定子配置都不同。

### 转子

步进电机基本上有三种类型的转子：

-   • 永磁转子：转子为永磁体，与定子电路产生的磁场对齐。这种转子可以保证良好的扭矩，并具有制动扭矩。这意味着，无论线圈是否通电，电机都能抵抗（即使不是很强烈）位置的变化。但与其他转子类型相比，其缺点是速度和分辨率都较低。图3显示了永磁步进电机的截面图。

![Permanent Magnet Stepper Motor](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图3: 永磁步进电机

-   • 可变磁阻转子：转子由铁芯制成，其形状特殊，可以与磁场对齐（请参见图1和图2）。这种转子更容易实现高速度和高分辨率，但它产生的扭矩通常较低，并且没有制动扭矩。
-   • 混合式转子：这种转子具有特殊的结构，它是永磁体和可变磁阻转子的混合体。其转子上有两个轴向磁化的磁帽，并且磁帽上有交替的小齿。这种配置使电机同时具有永磁体和可变磁阻转子的优势，尤其是具有高分辨率、高速度和大扭矩。当然更高的性能要求意味着更复杂的结构和更高的成本。图3显示了这种电机结构的简化示意图。线圈A通电后，转子N磁帽的一个小齿与磁化为S的定子齿对齐。与此同时，由于转子的结构，转子S磁帽与磁化为N的定子齿对齐。尽管步进电机的工作原理是相同的，但实际电机的结构更复杂，齿数要比图中所示的更多。大量的齿数可以使电机获得极小的步进角度，小至0.9°。

![Hybrid stepper motor](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图4: 混合式步进电机

### 定子

定子是电机的一部分，负责产生转子与之对齐的磁场。定子电路的主要特性与其相数、极对数以及导线配置相关。 相数是独立线圈的数量，极对数则表示每相占用的主要齿对。两相步进电机最常用，三相和五相电机则较少使用（请参见图5和图6）。

![Two-phase stator winding (left), three-phase stator winding (right)](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图5: 两相定子绕组（左）和三相定子绕组（右）

![Two-phase, one pole pair stator (left), two-phase, two pole pair stator (right). The letters show the magnetic field generated when positive voltage is applied between A+ and A-](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图6：两相单极定子（左）和两相双极定子（右）。在A +和A-之间施加正电压时产生的磁场用字母N和S表示。

## 步进电机的控制

从上文我们知道，电机线圈需要按特定的顺序通电，以产生转子将与之对齐的磁场。可以向线圈提供必要的电压以使电机正常运行的设备有以下几种（从距离电机更近的设备开始）：

-   晶体管桥：从物理上控制电机线圈电气连接的设备。晶体管可以看作是电控断路器，它闭合时线圈连接到电源，线圈中才有电流通过。每个电机相位都需要一个晶体管电桥。
-   预驱动器：控制晶体管激活的设备，它由MCU控制以提供所需的电压和电流。
-   MCU：通常由电机用户编程控制的微控制器单元，它为预驱动器生成特定信号以获得所需的电机行为。

图7为步进电机控制方案的简单示意图。预驱动器和晶体管电桥可以包含在单个设备中，即驱动器。

![Motor control basic scheme](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图7: 电机控制基本方案

### 步进电机驱动器类型

市面上有各种不同的 [步进电机驱动器](https://www.monolithicpower.cn/cn/products/motor-drivers/stepper-motor-drivers.html)，它们针对特定应用具有不同的功能。但其最重要的特性之一与输入接口有关，最常见的几种输入接口包括：

-   Step/Direction （步进/方向） –在Step引脚上发送一个脉冲，驱动器即改变其输出使电机执行一次步进，转动方向则由Direction引脚上的电平来决定。
-   Phase/Enable（相位/使能） –对每相的定子绕组来说，Enable决定该相是否通电， Phase决定该相电流方向，。
-   PWM – 直接控制上下管FET的栅极信号。

步进电机驱动器的另一个重要特性是，除了控制绕组两端的电压，它是否还可以控制流过绕组的电流：

-   拥有电压控制功能，驱动器可以调节绕组上的电压，产生的扭矩和步进速度仅取决于电机和负载特性。
-   电流控制驱动器更加先进，因为它们可以调节流经有源线圈的电流，更好地控制产生的扭矩，从而更好地控制整个系统的动态行为。

### 单极/双极电机

另一个可能对电机控制产生影响的特性是其定子线圈的布置，它决定了电流方向的变化方式。为了实现转子的运动，不仅要给线圈通电，还要控制电流的方向，而电流方向决定了线圈本身产生的磁场方向（见图8）。

步进电机可以通过两种不同的方法来控制电流的方向。

![Direction of the magnetic field based on the direction of the coil current](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图8: 根据线圈电流方向控制磁场方向

在单极步进电机中，线圈的中心点连有一根引线（请参见图9），这样可以通过相对简单的电路和组件来控制电流方向。该中央引线（AM）连接输入电压VIN（见图8）。如果MOSFET 1导通，则电流从AM流向A +。如果MOSFET 2导通，则电流从AM流向A-，在相反方向上产生磁场。如上所述，这种方法可以简化驱动电路（仅需要两个半导体），但缺点是一次仅使用了电机中铜导体的一半，这意味着如果线圈中流过相同的电流 ，则磁场强度仅为使用全部铜导体时的一半。另外，由于电机输入引线更多，这类电机较难构造。

![Unipolar Stepper Motor driving circuit](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图9: 单极步进电机驱动电路

在双极步进电机中，每个线圈只有两条引线，而且为了控制方向，必须使用H桥（请参见图10）。如图8所示，如果MOSFET 1和4导通，则电流从A +流向A-；如果MOSFET 2和3导通，则电流从A-流向A +，产生相反方向的磁场。这种方案需要更复杂的驱动电路，但可以最大限度利用电机铜量而实现最大扭矩。

![Bipolar Stepper Motor driving circuit](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图10: 双极步进电机驱动电路

随着技术的不断进步，[单极电机](https://www.monolithicpower.cn/cn/support/videos/stepper-motor-driver-from-mps.html)的优势逐步弱化，双极步进电机成为目前最流行的电机类型。

## 步进电机驱动技术

步进电机主要有四种不同的驱动技术：

-   • 波动模式：一次仅一个相位通电（见图11）。为简单起见，如果电流从某相的正引线流向负引线（例如，从A +到A-），则我们称为正向流动；否则，称为负向流动。从下图左侧开始，电流仅在A相中正向流动，而用磁体代表的转子与其所产生的磁场对齐。接着，电流仅在B相中正向流动，转子顺时针旋转90°以与B相产生的磁场对齐。随后，A相再次通电，但电流负向流动 ，转子再次旋转90°。 最后，电流在B相中负向流动，而转子再次旋转90°。

![Wave mode steps](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图11: 波动模式步进

-   全步模式：两相始终同时通电。图12显示了该驱动模式的步进步骤。其步骤与波动模式类似，最大的区别在于，全步模式下，由于电机中流动的电流更多，产生的磁场也更强，因此扭矩也更大。

![Full step mode steps](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图12: 全步模式步进

-   半步模式是波动模式和全步模式的组合（请参见图12）。这种模式可以将步距减小一倍（旋转45°，而不是90°）。其唯一的缺点是电机产生的扭矩不是恒定的，当两相都通电时扭矩较高，只有一相通电时扭矩较小。

![Half Step mode steps](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图13: 半步模式步进

-   • 微步模式：可以看作是半步模式的增强版，因为它可以进一步减小步距，并且具有恒定的扭矩输出。这是通过控制每相流过的电流强度来实现的。与其他方案相比，微步模式需要更复杂的电机驱动器。图14显示了微步模式的工作原理。假设IMAX是一个相位中可以通过的最大电流，则从图中左侧开始，在第一个图中IA = IMAX，IB = 0。下一步，控制电流以达到IA = 0.92 x IMAX，IB = 0.38 x IMAX，它产生的磁场与前一个磁场相比顺时针旋转了22.5°。控制电流达到不同的电流值并重复此步骤，将磁场旋转45°、67.5°和90°。与半步模式相比，它将步距减少了一半；但还可以减少更多。使用微步模式可以达到非常高的位置分辨率，但其代价是需要更复杂的设备来控制电机，并且每次步进产生的扭矩也更小。扭矩与定子磁场和转子磁场之间的夹角正弦成正比；因此，当步距较小时，扭矩也较小。这有可能会导致丢步，也就是说，即使定子绕组中的电流发生了变化，转子的位置也可能不改变。

![Microstepping](assets/img/3/3/4/334253c49a2aa15d5cf3f0133eff518de747c6b08140bdcf73356d69741ae5b7.png)

图14: 微步模式步进

## 步进电机的优缺点

现在我们已了解了步进电机的工作原理，再总结一下各类电机的优缺点将非常有帮助。

### 优点：

-   得益于其内部结构，步进电机不需要传感器来检测电机位置。步进电机是通过执行“步进”来运动的，因此只需简单地计算步数就可以获得给定时间的电机位置。
-   此外，步进电机的控制非常简单。它也需要驱动器，但不需要复杂的计算或调整即可正常工作。与其他电机相比，其控制工作量通常很小。而且，如果采用微步模式，还可以实现高达0.007°的位置精度。
-   步进电机在低速时可提供良好的扭矩，也可以很好的保持位置，而且使用寿命长。

### 缺点：

-   • 当负载扭矩过高时可能会失步。由于无法获知电机的实际位置，因此会对控制产生负面影响。采用微步模式时更易产生此问题。
-   • 步进电机即使在静止时也总是消耗最大电流，因此会降低效率并可能导致过热。
-   • 步进电机扭矩小，在高速下会产生很大的噪音。
-   • 步进电机具有低功率密度和低扭矩惯性比。

总而言之，当您需要成本低廉、易于控制的解决方案，且对高速时的效率和扭矩要求不高时，步进电机是最好的选择。

要了解如何为您的项目选择正确的电机类型，并进一步了解步进电机、有刷电机和无刷电机之间的区别，请单击 [此处](https://www.monolithicpower.cn/cn/catalog/category/view/id/535/)。